# 2025年8月23日

## 面试题

### 什么是事务以及事务的四大特性

- 必答内容

事务是数据库中的基本概念，是指一组操作的集合，而这一组操作要么同时成功，要么同时失败，从而保证数据库中数据的正确性和完整性

那事务呢，具有四大特性，也就是我们常说的ACID，分别是：原子性、一致性、隔离性、持久性。那接下来，我就分别来聊聊这四大特性

1. 原子性指的是事务中的这一组操作，是不可分割的最小操作单元了，操作要么全部成功，要么全部失败
2. 一致性是指在事务操作的前后，必须使数据处于一致的状态
3. 隔离性指的是数据库中提供了隔离机制，保证事务在不受外部并发操作的影响的独立环境中运行
4. 持久性就比较简单了，就是事务一旦提交或回滚了，它对数据库的改变就是永久的

- 可能继续发问的问题

【1】你刚才提到了并发事务，那并发事务回引发哪些问题

并发事务引发的问题，主要有这么几个

- 脏读：就是一个事务，读取到了另一个事务还没有提交的数据
- 不可重复读：指的是在同一个事务中，先后读取同一条记录，但两次读取的数据不同
- 幻读：指的是一个事务按照条件查询数据时，没有对应的行，但是插入时，又发现这行数据已经存在了好像出现了幻觉

【2】如何解决这些问题呢

那这些问题，在数据库系统中都已经解决了。在数据库中提供了不同的隔离级别来解决这些问题，分别有以下几种

- READ UNCOMMITED：读未提交。这种隔离级别下，会出现脏读、不可重复读、幻读问题
- READCOMMITED：读已提交。这种隔离级别，解决了脏读问题，但是会出现不可重复读、幻读问题
- REPEATABLEREAD：可重复读。这种隔离级别，解决了脏读、不可重复读问题，但是会出现幻读问题
- SERIALIZABLE：串行化。解决了上述所有的并发事务问题

而在MySQL数据库中，默认的隔离级别是REPEATABLE READ（可重复读）

【3】那为什么没有用SERIALIZABLE（串行化）这种隔离级别呢

其实，隔离级别，也不是越高越好。因为隔离级别高了，确实可以解决并发事务引发的问题，但是隔离级别越高，性能也越低

> !!! example "午间演讲示例"
> 事务是一组操作的集合，要么全成功，要么全失败。它的四大特性分别是：原子性、一致性、隔离性和持久性。

### 你项目中事务是如何实现的

[传智播客-面试知识点 - 飞书云文档](https://jxwi7qorep.feishu.cn/wiki/M6rAwK4tziXx8Mk6kOZcgnPQnvc#share-DhJFddcQGoIi5gxyK7rc56RCnze)

> !!! example "午间演讲示例"
> 使用`@Transactional`注解来控制事务

### 请介绍一下你知道的排序算法有哪些

[传智播客-面试知识点 - 飞书云文档](https://jxwi7qorep.feishu.cn/wiki/M6rAwK4tziXx8Mk6kOZcgnPQnvc#share-Oap9dtfOOoAq1JxiRT4cdTwKn5c)

> !!! example "午间演讲示例"
> 常见的排序算法有：冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序等

### 冒泡排序的实现思路

[传智播客-面试知识点 - 飞书云文档](https://jxwi7qorep.feishu.cn/wiki/M6rAwK4tziXx8Mk6kOZcgnPQnvc#share-YdGudVWqVoH8ylxSjohcT1DZnNR)

参考下图

1. 将整个数组分成【未排序】和【已排序】两个区域
2. 每一轮冒泡在【未排序】中从左向右，相邻两数进行比较（图中的 i 与 i+1 处），若它们逆序则交换位置，当这一轮结束时，【未排序】中最大的数会交换至【已排序】
3. 这样进行多轮冒泡操作，【已排序】逐渐扩大，而【未排序】逐渐缩小，直至缩减为一，算法结束

![](https://raw.githubusercontent.com/12age/blog-img/main/network-asset-yk6baz03t0l000d7w33fkcr5933h2ajvDIYvAdFwBdezDGxvAdazDY-20250822210333-7u2p2dv.gif)

> !!! example "午间演讲示例"
> 冒泡排序就是不断比较相邻的两个数，如果顺序错了就交换。
>
> 每一轮结束，最大的数都会被“冒”到最后。
>
> 轮数增加，已排序区扩大，直到所有数都排好序。

### 冒泡排序如何优化

[传智播客-面试知识点 - 飞书云文档](https://jxwi7qorep.feishu.cn/wiki/M6rAwK4tziXx8Mk6kOZcgnPQnvc#share-Jkzidv250oAv3tx6LoHcauMGn0g)

![](https://raw.githubusercontent.com/12age/blog-img/main/network-asset-ymjew503t0n000d7w32y7zp1onxrr2auDIYvAdFwBdezDGxvAdazDY-20250822210340-bojjm53.gif)

> !!! example "午间演讲示例"
> 在冒泡排序的优化中，我们通过记录每一轮最后交换的位置，来缩小未排序区的范围。
>
> 这样每一轮就不会对已排序的部分重复比较，避免了不必要的操作。
>
> 如果某一轮没有发生交换，说明数组已经有序，可以提前结束排序。
